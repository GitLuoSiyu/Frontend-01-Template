# 每周总结可以写在这里

## 标题：小型下棋游戏的思考

本周的作业是完成课堂上的三子棋，先跟着老师的课程步骤完成了三子棋基础版之后，随后突发奇想，想完成一个四子棋(结果木得)，随后照搬三子棋的想法，写了一个五子棋。棋盘用canvas画，至于赢法，这次改用把所有赢得可能性全部列举出来一一对比。难度一下子降低了，在这里加上一个悔棋的功能，欲盖弥彰一下，哈哈哈。

### 五子棋的实现思路
- 赢法数组
用一个三维的数组记录五子棋的所有赢法。

- 每种赢法的统计数组
我们用一维数组来记录每种赢法

- 如何判断输赢
判断输赢的方法

- 实现AI落子
这部分是重点，算法设计精准，AI的棋艺就高

### 赢法数组
先定义一个三维的数组，用于存放所有赢的情况。
```javascript
var wins = [];
for (var i = 0; i < 15; i++) {
    wins[i] = [];
    for (var j = 0; j < 15; j++) {
        wins[i][j] = [];
    }
}
```
定义count用于记录赢的方法种类数量，然后再遍历所有赢的情况，包括横向、纵向、斜向、反斜向，这是五个棋子呈横的形式赢的情况。
这里有三个循环，第一个循环是指每一条横线。第二个循环指的是摆成五个子，第一个子的纵坐标。第三个循环是摆满五个棋子，里重点说说为什么j<15。如果你想更好地理解，可以代些数进去看一下是什么情况。如果j还比10大的话就会超出棋盘。
以此类推，纵向、斜向、反斜向也是同理：
```javascript
// 横线赢法
for (var i = 0; i < 15; i++) {
    for (var j = 0; j < 11; j++) {
        for (var k = 0; k < 5; k++) {
            wins[i][j + k][count] = true;
        }
        count++;
    }
}

// 竖线赢法
for (var i = 0; i < 15; i++) {
    for (var j = 0; j < 11; j++) {
        for (var k = 0; k < 5; k++) {
            wins[j + k][i][count] = true;
        }
        count++;
    }
}

// 正斜线赢法
for (var i = 0; i < 11; i++) {
    for (var j = 0; j < 11; j++) {
        for (var k = 0; k < 5; k++) {
            wins[i + k][j + k][count] = true;
        }
        count++;
    }
}

// 反斜线赢法
for (var i = 0; i < 11; i++) {
    for (var j = 14; j > 3; j--) {
        for (var k = 0; k < 5; k++) {
            wins[i + k][j - k][count] = true;
        }
        count++;
    }
}
```
最后在后台输出总共有多少种赢法。我们由此知道，15*15的棋盘总共有572种赢法，所有赢法计算机都知道了，所以，如果代码打得好，你根本无法赢AI。

### 赢法的统计数组
这是一个一维的数组，用来计算某种赢法是否达成。上面列举了所有的赢法，那在某赢法中成功落下一个棋子，那我们就为该种赢法的值加1，直到加5就实现了此种赢法，实现结束游戏。那如果该赢法中有另一方的棋子，此种赢法报废。大概就是这么一个思路。计算机落子的目的就是去破坏你某种赢法的可行性，所以计算机落子的风格跟人有很大的区别。
定义并实例化两个数组，一个用来存放玩家赢法的数组，另一个用来存放电脑赢法的数组。
还定义了一个over变量，标志游戏的状态(开始or结束)。

在单击事件，成功落子后进行一个循环。
这个循环遍历所有的赢法，如果某种赢法里有棋子，就myWin[k]++，如果myWin[k] == 5成立了，改变over的标志，就代表你赢了。如果你下够五个子，就弹窗提示你赢了。特别注意，这里没有像winter老师那样对可能赢得步骤进行判断，而是直接点击事件后执行结果，然后根据结果判断输赢，先执行结果，再判断输赢。

### AI判断有效落棋点
在完成落子统计后判断是否结束游戏，如果没结束，就轮到AI下棋，AI下棋调用computerAI()方法。在点击鼠标的时候需要判断是否轮到用户落子,更改落棋的判断，如果鼠标点击，只下黑棋，并且只改变黑棋的频数统计。接下来实现computerAi()方法的棋步权值。首先定义并实例化myScore[]与computerScore[]两个数组，用于存放各个棋点的落子价值，再分别遍历人和计算机的所有赢法，如果有1、2、3、4子，分别为棋点附权值。

### 实现AI落子
接下来我们找到计算机落子的最佳坐标，然后在这个坐标上落子，就实现了计算机落子的功能了,为了找到棋盘坐标最高权值和其坐标点，这里定义三个变量max、u和v 。通过上遍历所有赢法的值后，这里只要判断比较在哪一方的赢法中落子价值大，主要是自己向着赢的方向前进和不让对方赢的方向进行阻挡。

得到最大权值的坐标后，我们就要实现在该位置落子,落完子后要对落子的位置进行统计，如果达到赢的情况就终止游戏，否则把落子权交给鼠标。

### 简单梳理思路

本次仿写的五子棋和三子棋差异不大，主要注意的地方有三点:
①赢法数组: 用一个三维的数组记录五子棋的所有赢法。每种赢法都有一个值，值达到5就结束游戏;②确定计算机落子点:通过为某种赢法附一个权值，权值最大的就是落子价值最大的;③实现计算机落子:通过上一步AI找到了权值最大的落子坐标后就可以实现落子了。
